function randInt(min, max) {
	return min + (Math.floor(Math.random()*(max-min)));
}

let decolorMode = false;
let blocksOnly = false;
let writeLimit = state.worldModel.char_rate[0];

const calculateClearTime = function(value, timeMS, tileContent) {
	if(tileContent instanceof Array) tileContent = tileContent.join("");
	tileContent = (tileContent.replace(/ /g, "").replaceAll("⠀", "").length)/128;

	value /= 128; //(working with whole tiles here)

	if(timeMS !== 1000) {
		value *= 1000/timeMS;
		timeMS *= 1000/timeMS;
	}

	if(state.userModel.is_member) return 1; // (members can send 128 spaces in 1 socket message)
	return Math.ceil((timeMS/value * tileContent));
}

const wipeTile = function(tx, ty) {
	if(state.userModel.is_member) {
		socket.send(JSON.stringify({
			kind: "write",
			edits: [[ty, tx,0,0,randInt(1682530403503, Date.now())," ".repeat(128),1,0]]
		}));
	} else {
		let tileCoord = ty+","+tx;
		if(!tiles[tileCoord]) return;
		let tileContent = tiles[tileCoord].content;
		let links = tiles[tileCoord]?.properties.cell_props || {};
		let edits = [];
		for(var x = 0; x < 16; x++) {
			for(var y = 0; y < 8; y++) {
				if(blocksOnly && tileContent[y*16 + x] !== "\u2588") continue;
				if(tileContent[y*16 + x] === " " || tileContent[y*16 + x] === "⠀" /*u2800*/ && !(links[y+""])) continue;
				edits.push([ty, tx, y, x, randInt(1682530403503, Date.now()), " ", 0, 0]);
			};
		};
		socket.send(JSON.stringify({
			kind: "write",
			edits: edits
		}));
	}
};

const decolorTile = function(tx, ty) {
	let tileCoord = ty+","+tx;
	if(!tiles[tileCoord]) return;
	let tileColors = tiles[tileCoord].properties.color;
	let tileContent = tiles[tileCoord].content;
	let edits = [];
	if(!tileColors) return;
	if(!(tileColors.filter(x=>x).length)) return;
	for(var x = 0; x < 16; x++) {
		for(var y = 0; y < 8; y++) {
			if(tileColors[y*16 + x] === 0) continue;
			edits.push([ty, tx, y, x, randInt(1682530403503, Date.now()), tileContent[y*16 + x], 0, 0, 0xdddddd]);
		};
	};
	socket.send(JSON.stringify({
		kind: "write",
		edits: edits
	}));
}

function clearTileRange(minX, minY, maxX, maxY) {
	let IntRange = (min, max) => {
		if(min > max) throw new RangeError("Minimum is greater than maximum!");

		let list = [];

		for(let i = min; i <= max; i++) {
			list.push(i);
		};

		return list;
	};

	const yValues = IntRange(minY, maxY).map(e => e*-1);
	const xValues = IntRange(minX, maxX);

	let clearingList = [[4.5682e20, -2.8432e20]];
	let intervalList = [0];

	for(let i = minY; i <= maxY; i++) {
		for(let x = minX; x <= maxX; x++) {
			let tileCoord = i+","+x;
			if(!tiles[tileCoord]) tiles[tileCoord] = {
				content: new Array(128).fill(".")
			}
			if(!tiles[tileCoord].content.join("").replace(/ /g, "").replaceAll("⠀", "").length) continue;
			clearingList.push([x, i]);
			let tileClearTime = calculateClearTime(writeLimit, state.worldModel.char_rate[1], tiles[tileCoord].content.join("").replace(/ /g, "").replaceAll("⠀", ""));
			intervalList.push(tileClearTime + intervalList[intervalList.length - 1]);
		};
	};

	const totalTime = intervalList[intervalList.length - 1];

	for(var i in clearingList) {
		let tile = clearingList[i];
		setTimeout(()=>{
			if(decolorMode) return decolorTile(tile[0], tile[1]);
			return wipeTile(tile[0], tile[1]);
		}, intervalList[i]);
	}

	clearerChatResponse(`Clearing ${clearingList.length} tiles, expected time: ${totalTime/1000} seconds`);
};

var sel = new RegionSelection();
sel.charColor = "#ff0000";
sel.color = "rgba(123, 123, 123, 0.1)";
sel.tiled = true;
sel.init();
sel.onselection(function(coordA, coordB, regWidth, regHeight) {
	var minTileX = coordA[0];
	var minTileY = coordA[1];
	var maxTileX = coordB[0];
	var maxTileY = coordB[1];
	clearTileRange(minTileX, minTileY, maxTileX, maxTileY);
});

function clearerChatResponse(msg) {
	addChat(null, 0, "user", "[ Clearer ]", msg, "Clearer", ...[1,0,0], "#EE0000", getDate());
};
var clearrange_subcommands = {
	help: () => {
		clearerChatResponse("<ul><li><b>Commands</b></li><li>/clear spawn, for inside main spawn</li><li>/clear decolor, to eliminate color</li><li>/clear blocksonly, only removes █s</li></ul>");
	},
	decolor: () => {
		decolorMode = !decolorMode;
		clearerChatResponse(`Set decolor mode to ${decolorMode}`);
	},
	blocksonly: () => {
		blocksOnly = !blocksOnly;
		clearerChatResponse(`Set blocks only mode to ${blocksOnly}`);
	},
	writelimit: (x) => {
		if(x === "r") x = state.worldModel.char_rate[0];
		if(Number.isNaN(x*1)) return clearerChatResponse(`Invalid input`);
		x *= 1;
		writeLimit = x;
		clearerChatResponse(`Set write limit to ${x} chars/second`)
	}
};
client_commands.clear = ([subcommand, param]) => {
	if(!subcommand) {
		sel.startSelection();
		clearerChatResponse("Select tiles to be cleared");
	} else {
		if(subcommand in clearrange_subcommands) {
			clearrange_subcommands[subcommand](param);
		} else {
			clearerChatResponse("Invalid subcommand");
		};
	};
}
