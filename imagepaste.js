var chosenX = 0; var chosenY = 0; var placeX = 0; var placeY = 0; var incrX = 0; var incrY = 0; var upload = document.createElement("input"); upload.setAttribute("id", "FileUpload"); upload.setAttribute("type","file"); upload.setAttribute("accept", "image/png, image/jpeg"); document.body.appendChild(upload); Permissions.can_paste = function() {return true;}; document.getElementById('FileUpload').onchange = function (evt) {     var tgt = evt.target || window.event.srcElement,         files = tgt.files;     if (FileReader && files && files.length) {         var fr = new FileReader();         fr.onload = function () {             SOURCEFORIMAGE = fr.result;         };         fr.readAsDataURL(files[0]);     }     else {     }; }; menu.addOption("Image Generator Upload", function() {document.getElementById('FileUpload').click()}); alert("This adds two functions to the menu, one to upload and one to paste an image. It will paste it directly to where the cursor is."); menu.addOption("Image Generator", function() {renderFrame(SOURCEFORIMAGE)});  function nextCoordOver() { placeX = chosenX + incrX; incrX++; };  function nextCoordDown() { incrX = 0; placeX = chosenX; incrY++; placeY = chosenY + incrY; };  function resetCoords() { incrX = 0; incrY = 0; placeX = chosenX; placeY = chosenY; };  function calculateWriteCoords() { return[Math.floor(placeY / tileR), Math.floor(placeX / tileC), placeY - Math.floor(placeY / tileR) * tileR, placeX - Math.floor(placeX / tileC) * tileC] };  var newArray = []; function renderFrame(IMGSRC) { nextCoordDown(); chosenX = (cursorCoords[0] * 16) + cursorCoords[2]; chosenY = (cursorCoords[1] * 8) + cursorCoords[3]; var scale = Math.round(Number(prompt("Input a width in characters. Output image will not be exactly that size, but will be close."))/4); var hex = (dec) => { dec = Math.floor(dec); return (dec < 16 ? "0" : "") + dec.toString(16) }, img = new Image(), canvas = document.createElement("canvas"), ctx = canvas.getContext("2d"); img.src = IMGSRC;     nextCoordDown(); img.onload = () => { let width = img.width; let height = img.height; if(img.width != (scale * 2)) { width = scale * 2; height = width * img.height / img.width; } canvas.width = (width - (width % 2))*2; canvas.height = (height - (height % 4)); ctx.drawImage(img, 0, 0, canvas.width, canvas.height); var data = ctx.getImageData(0, 0, canvas.width, canvas.height).data, editBufferIMG = []; for (var i = 0; i < canvas.height * canvas.width * 4; i += canvas.width * 4) { for (var j = 0; j < canvas.width * 4; j += 4) { let alpha = data[i + j + 3] / 255; colorPix = parseInt(hex(data[i + j] * alpha + 255 - data[i + j + 3]) + hex(data[i + j + 1] * alpha + 255 - data[i + j + 3]) + hex(data[i + j + 2] * alpha + 255 - data[i + j + 3]),16); editBufferIMG.push(calculateWriteCoords().concat(["",String.fromCodePoint(9608),"",colorPix])); nextCoordOver(); }; nextCoordDown(); }; newArray = editBufferIMG; var i,j,temparray,chunk = 511; for (i=0,j=editBufferIMG.length; i<j; i+=chunk) { temparray = editBufferIMG.slice(i,i+chunk); var data = { edits: JSON.stringify(temparray) }; ajaxRequest({ type: "POST", url: "https://ourworldoftext.com/" + state.worldModel.pathname, data: data            }); }; resetCoords(); } }
